#include <WiFi.h>
#include <AsyncTCP.h>
#include <ESPAsyncWebServer.h>
#include <DHT.h>
#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <ESP32Servo.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <freertos/semphr.h>
#include <freertos/queue.h>
#include <ArduinoJson.h>

// WiFi Credentials
#define WIFI_SSID "Wokwi-GUEST"
#define WIFI_PASS ""

// Hardware Pins
#define PIR_PIN          13
#define DOOR_PIN         14
#define LDR_PIN          34
#define DHT_PIN          15
#define LOCK_SERVO_PIN   33
#define CURTAIN_SERVO_PIN 18
#define BUZZER_PIN       12
#define RELAY_PIN        27
#define WARNING_LED_PIN  32

// Constants
#define LOG_INTERVAL     1000
#define WEBSOCKET_PORT   80
unsigned long lastLogTime = 0;

// Semaphores
SemaphoreHandle_t relayMutex;
SemaphoreHandle_t servoMutex;

// Queue
QueueHandle_t keypadQueue;

// Event Group
EventGroupHandle_t systemEvents;
#define WARNING_ACTIVE_BIT (1 << 0)

// Objects
AsyncWebServer server(WEBSOCKET_PORT);
AsyncWebSocket ws("/ws");
DHT dht(DHT_PIN, DHT22);
LiquidCrystal_I2C lcd(0x27, 16, 2);
Servo lockServo;
Servo curtainServo;

// Keypad Setup
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {23, 19, 18, 17};
byte colPins[COLS] = {16, 4, 2, 5};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
String password = "1234";
String input = "";

// WebSocket Functions
void onWebSocketEvent(AsyncWebSocket *server, AsyncWebSocketClient *client, AwsEventType type, void *arg, uint8_t *data, size_t len) {
  if (type == WS_EVT_CONNECT) {
    Serial.println("WebSocket client connected");
  } else if (type == WS_EVT_DISCONNECT) {
    Serial.println("WebSocket client disconnected");
  } else if (type == WS_EVT_DATA) {
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, data, len);
    if (error) {
      Serial.println("JSON parse error");
      return;
    }

    String type = doc["type"];
    int value = doc["value"];

    if (type == "lock") {
      if (xSemaphoreTake(servoMutex, portMAX_DELAY) == pdTRUE) {
        lockServo.write(value ? 90 : 0);
        xSemaphoreGive(servoMutex);
        sendLockStatus(value);
      }
    } else if (type == "light") {
      if (xSemaphoreTake(relayMutex, portMAX_DELAY) == pdTRUE) {
        digitalWrite(RELAY_PIN, value);
        xSemaphoreGive(relayMutex);
        sendLightStatus(value);
      }
    } else if (type == "curtain") {
      if (xSemaphoreTake(servoMutex, portMAX_DELAY) == pdTRUE) {
        curtainServo.write(value ? 180 : 0);
        xSemaphoreGive(servoMutex);
        sendCurtainStatus(value);
      }
    }
  }
}

void sendLockStatus(int value) {
  StaticJsonDocument<100> doc;
  doc["type"] = "lock_status";
  doc["value"] = value;
  String json;
  serializeJson(doc, json);
  ws.textAll(json);
}

void sendLightStatus(int value) {
  StaticJsonDocument<100> doc;
  doc["type"] = "light_status";
  doc["value"] = value;
  String json;
  serializeJson(doc, json);
  ws.textAll(json);
}

void sendCurtainStatus(int value) {
  StaticJsonDocument<100> doc;
  doc["type"] = "curtain_status";
  doc["value"] = value;
  String json;
  serializeJson(doc, json);
  ws.textAll(json);
}

void sendEnvironment(float temp, float hum, int light) {
  StaticJsonDocument<200> doc;
  doc["type"] = "environment";
  doc["temperature"] = temp;
  doc["humidity"] = hum;
  doc["light"] = light;
  String json;
  serializeJson(doc, json);
  ws.textAll(json);
}

void sendAlert(String message) {
  StaticJsonDocument<200> doc;
  doc["type"] = "alert";
  doc["message"] = message;
  String json;
  serializeJson(doc, json);
  ws.textAll(json);
}

void connectWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi Connected");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());
}

void keypadScannerTask(void *pvParameters) {
  while (1) {
    char key = keypad.getKey();
    if (key != NO_KEY) {
      xQueueSend(keypadQueue, &key, portMAX_DELAY);
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}

void logSystemStatus() {
  if (millis() - lastLogTime >= LOG_INTERVAL) {
    lastLogTime = millis();
    
    float temp = dht.readTemperature();
    float hum = dht.readHumidity();
    int light = analogRead(LDR_PIN);

    Serial.println("\n--- System Status ---");
    Serial.print("Temperature: ");
    Serial.println(temp);
    Serial.print("Humidity: ");
    Serial.println(hum);
    Serial.print("Light level: ");
    Serial.println(light);
    Serial.println("---------------------");
  }
}

void TaskAntiTheft(void *pvParameters) {
  bool lastState = false;
  while (1) {
    bool currentState = digitalRead(PIR_PIN) || !digitalRead(DOOR_PIN);
    
    if (currentState != lastState) {
      if (currentState) {
        xEventGroupSetBits(systemEvents, WARNING_ACTIVE_BIT);
        sendAlert("Phát hiện xâm nhập!");
        Serial.println("Cảnh báo: Phát hiện đột nhập!");
      } else {
        xEventGroupClearBits(systemEvents, WARNING_ACTIVE_BIT);
        sendAlert("Trạng thái an toàn");
        Serial.println("Trạng thái an toàn");
      }
      lastState = currentState;
    }
    vTaskDelay(100 / portTICK_PERIOD_MS);
  }
}

void TaskWarningHandler(void *pvParameters) {
  while (1) {
    EventBits_t bits = xEventGroupWaitBits(systemEvents, WARNING_ACTIVE_BIT, pdFALSE, pdFALSE, portMAX_DELAY);

    if (bits & WARNING_ACTIVE_BIT) {
      while (xEventGroupGetBits(systemEvents) & WARNING_ACTIVE_BIT) {
        digitalWrite(BUZZER_PIN, HIGH);
        digitalWrite(WARNING_LED_PIN, HIGH);
        vTaskDelay(200 / portTICK_PERIOD_MS);
        digitalWrite(BUZZER_PIN, LOW);
        digitalWrite(WARNING_LED_PIN, LOW);
        vTaskDelay(200 / portTICK_PERIOD_MS);
      }
      digitalWrite(BUZZER_PIN, LOW);
      digitalWrite(WARNING_LED_PIN, LOW);
    }
  }
}

void TaskAutomation(void *pvParameters) {
  int lastLight = -1;
  while (1) {
    int light = analogRead(LDR_PIN);
    
    if (abs(light - lastLight) > 50) {
      if (xSemaphoreTake(relayMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        bool newState = light < 1500;
        digitalWrite(RELAY_PIN, newState);
        sendLightStatus(newState);
        lastLight = light;
        xSemaphoreGive(relayMutex);
      }
    }
    vTaskDelay(500 / portTICK_PERIOD_MS);
  }
}

void TaskMonitoring(void *pvParameters) {
  float lastTemp = 0, lastHum = 0;
  while (1) {
    float temp = dht.readTemperature();
    float hum = dht.readHumidity();
    int light = analogRead(LDR_PIN);

    if (!isnan(temp) && !isnan(hum)) {
      if ((abs(temp - lastTemp) >= 0.5) || (abs(hum - lastHum) >= 1.0)) {
        sendEnvironment(temp, hum, light);
        if (temp > 35 || hum > 80) {
          char alertMsg[50];
          snprintf(alertMsg, sizeof(alertMsg), "Nhiệt độ: %.1fC, Độ ẩm: %.1f%%", temp, hum);
          sendAlert(alertMsg);
        }
        lastTemp = temp;
        lastHum = hum;
      }
    }
    vTaskDelay(5000 / portTICK_PERIOD_MS);
  }
}

void TaskKeypadLock(void *pvParameters) {
  lcd.init();
  lcd.backlight();
  lcd.print("NHAP MAT KHAU:");
  lcd.setCursor(0, 1);

  while (1) {
    char key;
    if (xQueueReceive(keypadQueue, &key, portMAX_DELAY) == pdTRUE) {
      switch (key) {
        case '*':
          input = "";
          lcd.setCursor(0, 1);
          lcd.print("                ");
          lcd.setCursor(0, 1);
          break;

        case '#':
          if (input == password) {
            xSemaphoreTake(servoMutex, portMAX_DELAY);
            lockServo.write(90);
            xSemaphoreGive(servoMutex);
            sendLockStatus(1);

            lcd.clear();
            lcd.print("MO CUA THANH CONG");
            sendAlert("Cửa đã mở");

            vTaskDelay(3000 / portTICK_PERIOD_MS);
            
            xSemaphoreTake(servoMutex, portMAX_DELAY);
            lockServo.write(0);
            xSemaphoreGive(servoMutex);
            sendLockStatus(0);
            
            lcd.clear();
            lcd.print("CUA DA KHOA");
          } else {
            lcd.clear();
            lcd.print("SAI MAT KHAU!");
            vTaskDelay(1500 / portTICK_PERIOD_MS);
            lcd.clear();
            lcd.print("NHAP MAT KHAU:");
          }
          input = "";
          lcd.setCursor(0, 1);
          break;

        default:
          if (input.length() < 6) {
            input += key;
            lcd.setCursor(input.length() - 1, 1);
            lcd.print("*");
          }
      }
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);

  // Initialize RTOS components
  systemEvents = xEventGroupCreate();
  keypadQueue = xQueueCreate(10, sizeof(char));
  relayMutex = xSemaphoreCreateMutex();
  servoMutex = xSemaphoreCreateMutex();

  // Setup hardware
  pinMode(PIR_PIN, INPUT);
  pinMode(DOOR_PIN, INPUT_PULLUP);
  pinMode(LDR_PIN, INPUT);
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(WARNING_LED_PIN, OUTPUT);
  
  digitalWrite(BUZZER_PIN, LOW);
  digitalWrite(RELAY_PIN, LOW);
  digitalWrite(WARNING_LED_PIN, LOW);

  // Configure servos
  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  
  lockServo.setPeriodHertz(50);
  lockServo.attach(LOCK_SERVO_PIN, 500, 2500);
  lockServo.write(0);
  
  curtainServo.setPeriodHertz(50);
  curtainServo.attach(CURTAIN_SERVO_PIN, 500, 2500);
  curtainServo.write(0);

  // Connect to WiFi
  connectWiFi();

  // Initialize WebSocket
  ws.onEvent(onWebSocketEvent);
  server.addHandler(&ws);
  server.begin();

  // Initialize LCD and sensors
  Wire.begin(21, 22);
  keypad.setDebounceTime(20);
  dht.begin();

  // Create tasks
  xTaskCreate(keypadScannerTask, "Keypad", 3072, NULL, 3, NULL);
  xTaskCreate(TaskWarningHandler, "Warning", 3072, NULL, 4, NULL);
  xTaskCreate(TaskAntiTheft, "AntiTheft", 4096, NULL, 3, NULL);
  xTaskCreate(TaskAutomation, "AutoLight", 4096, NULL, 2, NULL);
  xTaskCreate(TaskMonitoring, "Monitor", 6144, NULL, 2, NULL);
  xTaskCreate(TaskKeypadLock, "Lock", 6144, NULL, 4, NULL);
}

void loop() {
  ws.cleanupClients(); // Clean up disconnected WebSocket clients
}